# -*- coding: utf-8 -*-
"""Irish_job.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nq6EOB90bxQo6Q7ISddTOkGGE4VXqF9Y
"""

# -*- coding: utf-8 -*-
"""Irish_job.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R97sREBwXtICgYd1OJNu5HhL7NCkFsrO
"""

import pandas as pd
import requests
import json
import smtplib
# from email.mime.text import MIMEText
# from email.mime.multipart import MIMEMultipart
from datetime import datetime
import os
from datetime import datetime, timedelta
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders

headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "Accept": "application/json"
}


cookies = {
    "SoftLoginCA": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdGVwU3RvbmUgQ2FuZGlkYXRlIEF1dGgiLCJhdWQiOiIzMDEiLCJwdXJwIjoiU29mdExvZ2luIiwiY2lkIjoiMWZiZTE0ZTktZDFkMS00NTllLTg5YjktMTQ1NGQ3ZTdmYTViIiwibGVnYWN5SWQiOiI0YjYwMzU3ZC0zNWZkLTQ1NjAtYjhlZi04N2MyZGY3MzExNDIiLCJuYmYiOjE3NjIyNTg2NjMsImV4cCI6MTc3MDAzNDY2MywiaWF0IjoxNzYyMjU4NjYzfQ.x7hV80lbWSzOXLT9QlnRVd1pJ7wOYtFEq-WHhovI6GdrhtCaY4zdoxfXN170Kioro02ikACLVIyt7Kt6mF3y38agg2_V13D4PLgV0TAsBDN2bIWa03TOkUyLk1MhgEe4mQIhMyK6EBLNfq3FFTlDsJw9X0fz9SH3uLKJJ5FLCctElhhxG8jHaipfTTjc4y6WeZVCh4UZ_5MtjLphiOTbd7hrXTL_Z_wsig4mSjHOHjVHbswK3ZSD-8RIBtFvbZFrRUpCTI7ZYVlw428ikWjXSfWcOUUQADVF8kHCvFhClHEBNcx1_0nRpryQwpdq5KDrRDCPu-zwShS2AtsD8GBXPADBTUtvN2oqM67uCmjF93R4P8aSbC3tKc9-BpCcbPexX-bXGl8ZxwQt7HL1vnBJSS9DDkhnLKs8GaL9UyrD-r-YJ1rhnVupCmZ-0sPtDUO2lt_OlcDHxcN6QSHAkzJfelt8eU8L7Ni1jzeBqTgXibojH97bKpziOuziZYmcOpsCD0RKDgUqZJvabpLOaqqe_N-Eb5D5nonrwNINGMnma5uWB0nH8JaH2imHP7OqCODGeXHbM3dsNPK-7dPrHMTlb-iH-qmwLPrPxZHsDEoqxBA2Aae9pXl8BeIrz9LxbgrE8WRjCom5Hy032cbKurElatv1Yx4ZRvPFpDFGUBkkQz4",
    "SoftLoginCookie": "DL92limBnSx+eWan2Q9j6c03LZ6fLxl+UQtSSkcX+m+tF4ojTTNsUgGc01RYxdey1XWCDes2aBkCk0Wr5lL6Yk5xDrxmPfNVBXSxK1PKYGO7Cd05YzLOtE6DEQMBphO7F6JFDT1oCSLRGtoCT3fB93c8bHaWFudBT5kIQYqY3KbYEDg/ALOTsx8gGfZ6WvWm6wTOP6ZmVQ78MhNZRz3NqLjEtxagYYeRUX+IrCYChUY=",
    "STEPSTONEV5LANG": "en",
    "utag_main": "v_id:0199b16d1cb60047a8a2d7c605080506f00e506700978$_sn:26$_se:2$_ss:0$_st:1765067912184$eciduk:c$dc_visit:27$ses_id:1765066103490;exp-session$_pn:1;exp-session$PersistedFreshUserValue:0.1;exp-session$dc_event:2;exp-session$dc_region:eu-central-1;exp-session",
    "VISITOR_ID": "25a8fb16663ce6023a77af83f5245f09"
}

# -----------------------------
# 1️ Scrape IrishJobs API
# -----------------------------

url = 'https://www.irishjobs.ie/membersarea/api/recommendedjobs?count=500'

def fetch_jobs(url, headers, cookies):
    print("Fetching:", url)

    try:
        resp = requests.get(url, headers=headers, cookies=cookies)
    except Exception as e:
        print("Request failed:", e)
        return pd.DataFrame()

    print("Status Code:", resp.status_code)
    print("Preview:", resp.text[:300])

    # Parse JSON
    try:
        data_json = resp.json()
    except ValueError:
        print("Response is NOT JSON — likely HTML or error page")
        return pd.DataFrame()

    # Check expected field
    if "recommendedJobs" not in data_json:
        print("❌ 'recommendedJobs' field missing in JSON")
        return pd.DataFrame()

    df = pd.DataFrame(data_json["recommendedJobs"])

    # Prevent KeyError
    if "isActive" not in df.columns:
        df["isActive"] = True   # default safe value

    return df


def preprocess(df):
  df = df[df["isActive"] == True]
# Convert dates and remove timezone
  df['datePosted'] = pd.to_datetime(df['datePosted'], errors='coerce').dt.tz_localize(None)
  df['dateExpire'] = pd.to_datetime(df['dateExpire'], errors='coerce').dt.tz_localize(None)
  return df

def addfeatur(df):
  df['days_to_expire'] = (df['dateExpire'] - df['datePosted']).dt.days
# Compute recentness (jobs within last 2 hours)
  df['is_recent'] = df['datePosted'] >= (datetime.now() - timedelta(hours=2))

  return df
# -----------------------------
# 3️⃣ Classify job type
# -----------------------------
def classify_job_type(row):
    """
    Classify job type based on title and salary.
    Returns: 'Part-Time', 'Full-Time', 'Temporary/Contract', 'Seasonal', 'Other'
    """
    title = str(row.get("title", "")).lower()
    salary = str(row.get("salary", "")).lower()

    # --- Check title first ---
    if any(word in title for word in ["part time", "part-time", "casual", "evening", "weekend"]):
        return "Part-Time"
    if any(word in title for word in ["full time", "full-time", "permanent"]):
        return "Full-Time"
    if any(word in title for word in ["temporary", "temp", "contract", "fixed term"]):
        return "Temporary/Contract"
    if any(word in title for word in ["seasonal", "christmas", "festive", "summer job"]):
        return "Seasonal"

    # --- If title doesn't help, check salary ---
    if "per hour" in salary or "hourly" in salary:
        return "Part-Time"
    if "per annum" in salary or "yearly" in salary or "annually" in salary:
        return "Full-Time"

    # --- Default fallback ---
    return "Other"
# -----------------------------
# 4️ Standardize county
# -----------------------------
# Mapping of towns/suburbs to counties
location_map = {
    # Counties
    "county dublin": "Dublin",
    "county meath": "Meath",
    "county cork": "Cork",
    "county kildare": "Kildare",
    "county armagh": "Armagh",
    "county wicklow": "Wicklow",
    "county louth": "Louth",

    # Full location formats
    "dublin, county dublin": "Dublin",
    "cork, county cork": "Cork",
    "kildare, county kildare": "Kildare",
    "armagh, county armagh": "Armagh",
    "bray, county wicklow": "Bray, Wicklow",
    "craigavon, county armagh": "Craigavon, Armagh",

    # Towns/suburbs (Place + County)
    "south dublin, dublin": "South Dublin, Dublin",
    "lucan and pettycanon": "Lucan And Pettycanon, Dublin",
    "palmerstown": "Palmerstown, Dublin",
    "clane": "Clane, Kildare",
    "newbridge": "Newbridge, Kildare",
    "swords": "Swords, Dublin",
    "blanchardstown": "Blanchardstown, Dublin",
    "celbridge, kildare": "Celbridge, Kildare",
    "malahide": "Malahide, Dublin",
    "leixlip": "Leixlip, Kildare",
    "rathcoole": "Rathcoole, Dublin",
    "tallaght": "Tallaght, Dublin",
    "summerhill": "Summerhill, Meath",
    "collegeland": "Collegeland, Armagh",
    "clondalkin": "Clondalkin, Dublin",
    "cornelscourt": "Cornelscourt, Dublin",
    "maynooth, kildare": "Maynooth, Kildare",
    "dublin city centre": "Dublin City Centre, Dublin",
    "greenoge": "Greenoge, Offaly",
    "fermoy, cork": "Fermoy, Cork",
    "balbriggan": "Balbriggan, Dublin",
    "mitchelstown, cork": "Mitchelstown, Cork",
    "ringaskiddy": "Ringaskiddy, Cork",
    "little island": "Little Island, Cork",
    "macroom, cork": "Macroom, Cork",
    "stillorgan north": "Stillorgan North, Dublin",
    "kimmage": "Kimmage, Dublin",
    "dun laoghaire": "Dun Laoghaire, Dublin",
    "dunmanway south": "Dunmanway South, Cork",
    "naas, kildare": "Naas, Kildare",
    "santry": "Santry, Dublin",
    "portmarnock": "Portmarnock, Dublin",
    "saggart": "Saggart, Dublin",
    "mallow, cork": "Mallow, Cork",
    "bishopstown": "Bishopstown, Cork",
    "carrigaline": "Carrigaline, Cork",
    "republic of ireland": "Ireland"
}

def standardize_county(location):
    if not isinstance(location, str):
        return "Other"

    loc = location.lower().strip()

    if loc in location_map:
        return location_map[loc]

    # Handle "Area, County X" general case
    for county in ["cork", "dublin", "kildare", "meath", "armagh", "wicklow", "louth", "limerick", "kerry", "offaly"]:
        if county in loc:
            place = loc.split(',')[0].strip().title()
            if "county" in place.lower():
                return county.capitalize()
            else:
                return f"{place}, {county.capitalize()}"

    return "Other"


#Importin SQLite3
import sqlite3
def save_to_db(df, db_path="jobs1.db"):
 if "job_id" in df.columns:
  df = df.drop_duplicates(subset=["job_id"], keep="first")
 conn = sqlite3.connect(db_path)  # auto-creates file if missing
 df.to_sql("irish_jobs", conn, if_exists="replace", index=False)
 conn.close()


if __name__ == "__main__":

    # 1️Fetch and preprocess jobs
    df = fetch_jobs(url, headers,cookies)
    df = preprocess(df)
    df = addfeatur(df)
    df["job_type"] = df.apply(classify_job_type, axis=1)
    df["county"] = df["location"].apply(standardize_county)

    # 2️Simplify location and drop unnecessary columns
    df['location'] = df["county"]
    df.drop(columns=["external","companyLogoAlt","companyLogo","companyId",
                     "companyUrl","listingGlobalId","id","applyUrl","county"], inplace=True)

    # 3️ Save main jobs database
    save_to_db(df, "jobs1.db")

    # 4️ Filter recent jobs (last 2 hours)
    now = datetime.now()
    recent_jobs = df[df['datePosted'] >= (now - timedelta(hours=2))]
    columns_to_keep = ["title", "companyName", "location", "salary",
                       "datePosted", "dateExpire", "url", "isActive", "job_type"]
    recent_jobs = recent_jobs[columns_to_keep]

    # 5️ Optionally save recent jobs
    save_to_db(recent_jobs, "recent_jobs.db")

    print("Pipeline completed successfully!")

#Unit Testing

def test_classify_job_type():
    test_row = {"title": "Part-Time Teacher", "salary": ""}
    assert classify_job_type(test_row) == "Part-Time"

def test_standardize_county():
    assert standardize_county("Dublin, County Dublin") == "Dublin"
    assert standardize_county("UnknownPlace") == "Other"


def test_pipeline():
    df = fetch_jobs(url, headers,cookies)
    df = preprocess(df)
    df = addfeatur(df)  # optional, if you want days_to_expire/is_recent
    df["job_type"] = df.apply(classify_job_type, axis=1)
    df["county"] = df["location"].apply(standardize_county)

    # Save to test DB
    save_to_db(df, "test_jobs.db")

    conn = sqlite3.connect("test_jobs.db")
    query = "SELECT * FROM irish_jobs LIMIT 10"
    df_db = pd.read_sql(query, conn)
    conn.close()

    # Checks
    assert not df_db.empty
    assert "job_type" in df_db.columns
    assert "datePosted" in df_db.columns

# Run unit tests
test_classify_job_type()
test_standardize_county()
test_pipeline()

print("All tests passed ✅")